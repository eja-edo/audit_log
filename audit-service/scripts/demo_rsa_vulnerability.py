"""
RSA PKCS#1 v1.5 Padding Oracle Attack Demo

This script demonstrates WHY the audit log service uses Ed25519 instead of RSA PKCS#1 v1.5.

SECURITY WARNING: This is for EDUCATIONAL PURPOSES ONLY.
The vulnerability shown here is a real attack vector against RSA PKCS#1 v1.5 signatures.

Attack Explanation:
===================
RSA PKCS#1 v1.5 has a known vulnerability where:
1. The padding structure is: 0x00 0x01 [padding bytes 0xFF...] 0x00 [hash]
2. Some implementations only check the prefix and hash, ignoring garbage after the hash
3. An attacker with a small public exponent (e=3) can forge signatures by computing cube roots

This is the famous "Bleichenbacher's e=3 RSA signature forgery" attack.
"""

import hashlib
import json
import base64
from datetime import datetime
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.backends import default_backend


def print_section(title: str):
    print(f"\n{'='*70}")
    print(f" {title}")
    print(f"{'='*70}\n")


# ============================================================================
# PART 1: Setup - Generate RSA keypair with e=3 (vulnerable)
# ============================================================================

print_section("PART 1: Generate RSA Key with e=3 (VULNERABLE)")

# Generate RSA key with e=3 (small public exponent - INSECURE)
# Note: In real attacks, e=3 makes cube root computation feasible
# Modern libraries default to e=65537 which is safer

# We'll use e=65537 for demo since cryptography library requires it
# But we'll simulate the vulnerability conceptually

key = rsa.generate_private_key(
    public_exponent=65537,  # Library requires this, but attack works with e=3
    key_size=2048,
    backend=default_backend()
)

private_key = key
public_key = key.public_key()

# Export keys
private_pem = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.PKCS8,
    encryption_algorithm=serialization.NoEncryption()
).decode()

public_pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
).decode()

print("RSA-2048 keypair generated")
print(f"Public exponent (e): {public_key.public_numbers().e}")


# ============================================================================
# PART 2: Create a legitimate audit event and sign it properly
# ============================================================================

print_section("PART 2: Create Legitimate Audit Event")

# Simulate an audit event
event_data = {
    "action": "user.login",
    "actor": "admin@company.com",
    "timestamp": datetime.utcnow().isoformat(),
    "ip_address": "192.168.1.100",
    "details": {
        "browser": "Chrome",
        "success": True
    }
}

# Canonical form (sorted keys, no whitespace)
canonical_event = json.dumps(event_data, sort_keys=True, separators=(',', ':'))
print(f"Canonical event:\n{canonical_event}\n")

# Sign with RSA PKCS#1 v1.5
signature_legit = private_key.sign(
    canonical_event.encode(),
    padding.PKCS1v15(),
    hashes.SHA256()
)

print(f"Legitimate signature (base64): {base64.b64encode(signature_legit).decode()[:50]}...")


# ============================================================================
# PART 3: Demonstrate the vulnerability - Bad verification implementation
# ============================================================================

print_section("PART 3: VULNERABLE Verification Implementation")


def vulnerable_verify_signature(message: bytes, signature: bytes, public_key) -> tuple[bool, str]:
    """
    INTENTIONALLY VULNERABLE signature verification.
    
    This implementation has the following flaws:
    1. It uses timing-dependent comparison
    2. It provides detailed error messages (oracle)
    3. It could be susceptible to Bleichenbacher's attack with e=3
    
    NEVER USE THIS IN PRODUCTION!
    """
    try:
        # Perform RSA operation: signature^e mod n
        pub_numbers = public_key.public_numbers()
        n = pub_numbers.n
        e = pub_numbers.e
        
        sig_int = int.from_bytes(signature, byteorder='big')
        decrypted_int = pow(sig_int, e, n)
        
        # Convert back to bytes
        key_size = (n.bit_length() + 7) // 8
        decrypted_bytes = decrypted_int.to_bytes(key_size, byteorder='big')
        
        # VULNERABILITY: Check PKCS#1 v1.5 padding loosely
        # Expected format: 0x00 0x01 [0xFF padding] 0x00 [DigestInfo + hash]
        
        if decrypted_bytes[0:2] != b'\x00\x01':
            return False, "PADDING_ERROR: Invalid header"  # Oracle leak!
        
        # Find the 0x00 separator
        try:
            separator_idx = decrypted_bytes.index(b'\x00', 2)
        except ValueError:
            return False, "PADDING_ERROR: No separator found"  # Oracle leak!
        
        # Check padding bytes are all 0xFF
        padding_bytes = decrypted_bytes[2:separator_idx]
        if not all(b == 0xFF for b in padding_bytes):
            return False, "PADDING_ERROR: Invalid padding bytes"  # Oracle leak!
        
        if len(padding_bytes) < 8:
            return False, "PADDING_ERROR: Padding too short"  # Oracle leak!
        
        # Extract the digest info + hash
        digest_info_and_hash = decrypted_bytes[separator_idx + 1:]
        
        # SHA-256 DigestInfo prefix (DER encoded)
        sha256_digest_info_prefix = bytes([
            0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
            0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
            0x00, 0x04, 0x20
        ])
        
        if not digest_info_and_hash.startswith(sha256_digest_info_prefix):
            return False, "HASH_ERROR: Invalid DigestInfo"  # Oracle leak!
        
        # Extract hash
        extracted_hash = digest_info_and_hash[len(sha256_digest_info_prefix):]
        
        # VULNERABILITY: Only check first 32 bytes, ignore trailing garbage
        extracted_hash = extracted_hash[:32]  # BUG: Should verify exact length!
        
        # Compute expected hash
        expected_hash = hashlib.sha256(message).digest()
        
        # VULNERABILITY: Non-constant-time comparison
        if extracted_hash == expected_hash:
            return True, "VALID"
        else:
            return False, "HASH_MISMATCH: Signature invalid"
            
    except Exception as ex:
        return False, f"ERROR: {str(ex)}"  # Oracle leak!


def secure_verify_signature(message: bytes, signature: bytes, public_key) -> tuple[bool, str]:
    """
    SECURE signature verification using the library's implementation.
    
    This is what the Audit Log Service actually uses.
    """
    try:
        public_key.verify(
            signature,
            message,
            padding.PKCS1v15(),
            hashes.SHA256()
        )
        return True, "VALID"
    except Exception:
        # Generic error - no oracle leak
        return False, "INVALID"


# Test legitimate signature with both implementations
print("Testing LEGITIMATE signature:\n")

result_vuln, msg_vuln = vulnerable_verify_signature(
    canonical_event.encode(), 
    signature_legit, 
    public_key
)
print(f"  Vulnerable impl: {msg_vuln}")

result_secure, msg_secure = secure_verify_signature(
    canonical_event.encode(), 
    signature_legit, 
    public_key
)
print(f"  Secure impl:     {msg_secure}")


# ============================================================================
# PART 4: Demonstrate Padding Oracle Attack
# ============================================================================

print_section("PART 4: Padding Oracle Attack Demonstration")

print("""
The Padding Oracle Attack works as follows:

1. ATTACKER sends modified signatures to the server
2. SERVER responds with DIFFERENT error messages:
   - "PADDING_ERROR" → attacker learns padding is wrong
   - "HASH_MISMATCH" → attacker learns padding is correct!
   
3. By analyzing responses, attacker can:
   - Learn the structure of valid padding
   - With e=3, forge signatures without the private key
   
Let's simulate probing the vulnerable implementation:
""")

# Simulate attacker probing with random signatures
import secrets

print("Simulating attacker probing with random signatures:\n")

for i in range(5):
    # Generate random "forged" signature
    fake_sig = secrets.token_bytes(256)  # 2048 bits = 256 bytes
    
    result, error_msg = vulnerable_verify_signature(
        canonical_event.encode(),
        fake_sig,
        public_key
    )
    
    # Attacker learns information from error messages!
    print(f"  Probe {i+1}: {error_msg}")

print("""
↑ Notice how the vulnerable implementation leaks information!
  Each different error message helps the attacker narrow down valid padding.
""")


# ============================================================================
# PART 5: Simulate Forged Signature Attempt
# ============================================================================

print_section("PART 5: Forged Signature Attack")

# Create a MALICIOUS event
malicious_event = {
    "action": "admin.delete_all_users",  # Attacker wants to inject this!
    "actor": "attacker@evil.com",
    "timestamp": datetime.utcnow().isoformat(),
    "ip_address": "evil-ip",
    "details": {"malicious": True}
}

malicious_canonical = json.dumps(malicious_event, sort_keys=True, separators=(',', ':'))

print(f"MALICIOUS event attacker wants to inject:")
print(f"{malicious_canonical}\n")

# Attacker tries to create a forged signature
# In a real Bleichenbacher attack with e=3, this could succeed!
# Here we demonstrate the concept:

malicious_hash = hashlib.sha256(malicious_canonical.encode()).digest()

# SHA-256 DigestInfo 
sha256_digest_info = bytes([
    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
    0x00, 0x04, 0x20
]) + malicious_hash

# Construct forged PKCS#1 v1.5 block
# Format: 0x00 0x01 [0xFF padding] 0x00 [DigestInfo]
# With e=3, attacker can compute cube root to get valid signature!

forged_block = b'\x00\x01' + (b'\xff' * 8) + b'\x00' + sha256_digest_info
# Pad to key size with garbage (the vulnerability ignores trailing bytes!)
forged_block += b'\x00' * (256 - len(forged_block))

print(f"Forged PKCS#1 block constructed ({len(forged_block)} bytes)")
print(f"First 50 bytes: {forged_block[:50].hex()}\n")

# With e=3, attacker would compute: forged_signature = cube_root(forged_block_as_int)
# Since we have e=65537, we can't easily do this, but the concept remains

# Try the forged block directly (won't work without cube root computation)
result_vuln, msg_vuln = vulnerable_verify_signature(
    malicious_canonical.encode(),
    forged_block,
    public_key
)
print(f"Forged sig vs Vulnerable impl: {msg_vuln}")

result_secure, msg_secure = secure_verify_signature(
    malicious_canonical.encode(),
    forged_block,
    public_key
)
print(f"Forged sig vs Secure impl:     {msg_secure}")


# ============================================================================
# PART 6: Why Ed25519 is better
# ============================================================================

print_section("PART 6: Why Audit Log Service Uses Ed25519")

print("""
The Audit Log Service uses Ed25519 instead of RSA PKCS#1 v1.5 because:

1. NO PADDING ORACLE VULNERABILITY
   - Ed25519 doesn't use padding schemes
   - Signatures are deterministic (same message → same signature)
   
2. CONSTANT-TIME VERIFICATION
   - Ed25519 libraries implement constant-time comparison
   - No timing side-channels
   
3. SMALLER & FASTER
   - Ed25519 signature: 64 bytes
   - RSA-2048 signature: 256 bytes
   - Ed25519 is ~10x faster for verification
   
4. SIMPLER IMPLEMENTATION
   - Less room for implementation bugs
   - No complex padding to get wrong

Comparison:
┌─────────────────┬─────────────────────┬──────────────────────┐
│                 │ RSA PKCS#1 v1.5     │ Ed25519              │
├─────────────────┼─────────────────────┼──────────────────────┤
│ Padding Oracle  │ VULNERABLE          │ NOT APPLICABLE       │
│ Signature Size  │ 256 bytes           │ 64 bytes             │
│ Verification    │ Slower              │ ~10x faster          │
│ Side-channels   │ Many known attacks  │ Designed to resist   │
│ Implementation  │ Complex             │ Simple               │
└─────────────────┴─────────────────────┴──────────────────────┘
""")


# ============================================================================
# PART 7: Test against actual Audit Log Service API
# ============================================================================

print_section("PART 7: Test Forged Signature Against Audit Log API")

import requests

API_URL = "http://localhost"

# Try to submit malicious event with forged signature
print("Attempting to submit MALICIOUS event with forged signature to API...\n")

try:
    response = requests.post(
        f"{API_URL}/v1/logs",
        json={
            "service_id": "attacker-service",
            "event_type": "ADMIN_DELETE_ALL",
            "event": malicious_canonical,
            "event_data": malicious_event,
            "signature": base64.b64encode(forged_block).decode(),
            "public_key_id": "attacker-service:v1234"
        },
        headers={"Content-Type": "application/json"},
        timeout=5
    )
    
    print(f"API Response Status: {response.status_code}")
    print(f"API Response: {response.json()}")
    
    if response.status_code != 200:
        print("\n✓ ATTACK BLOCKED! The API correctly rejected the forged signature.")
    else:
        print("\n✗ WARNING: Attack may have succeeded!")
        
except requests.exceptions.ConnectionError:
    print("Could not connect to API. Make sure docker-compose is running.")
except Exception as ex:
    print(f"Error: {ex}")


print_section("CONCLUSION")

print("""
This demo showed:

1. RSA PKCS#1 v1.5 has inherent vulnerabilities (Bleichenbacher's attack)
2. Detailed error messages create padding oracles
3. Ed25519 avoids these issues entirely

The Audit Log Service is SECURE because:
- It uses Ed25519 (not RSA PKCS#1 v1.5)
- It returns generic "rejected" errors (no oracle)
- It uses constant-time signature verification (PyNaCl)

To test with a REAL registered service, run:
  python scripts/register_service.py test-service "Test Service"
""")
